<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cyberpunk Voxel City</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a0b2e; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-family: monospace; font-size: 24px; pointer-events: none;
        }
    </style>
    <!-- Import map for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
      /* Hides common overlay IDs and classes used in Three.js examples and generated code */
      #info, #loading, #ui, #instructions, .label, .overlay, #description {
        display: none !important;
        opacity: 0 !important;
        pointer-events: none !important;
        visibility: hidden !important;
      }
      /* Ensure the body doesn't show selected text cursor interaction outside canvas */
      body {
        user-select: none !important;
      }
    </style>
  </head>
<body>
    <div id="loading">GENERATING VOXELS...</div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const COLORS = {
            bg: 0x180029,
            purpleDark: 0x2e004f,
            purpleLight: 0x5e17eb,
            neonBlue: 0x00f0ff,
            neonPink: 0xff00aa,
            gold: 0xffaa00,
            goldGlow: 0xffdd44,
            beam: 0xaa44ff
        };

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.bg);
        scene.fog = new THREE.FogExp2(COLORS.bg, 0.015);

        // Orthographic Camera for Isometric Voxel Look
        const aspect = window.innerWidth / window.innerHeight;
        const d = 35;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(32, 32, 32); // Isometric angle
        camera.lookAt(scene.position);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance optimization
        document.body.appendChild(renderer.domElement);

        // --- CONTROLS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minZoom = 0.5;
        controls.maxZoom = 2;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(COLORS.purpleDark, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(20, 50, 10);
        scene.add(dirLight);

        // Point lights for local glow
        const pointLight = new THREE.PointLight(COLORS.purpleLight, 2, 50);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        // --- POST PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 0.8; // Intensity of glow
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- MATERIALS ---
        const matBase = new THREE.MeshStandardMaterial({ color: COLORS.purpleDark, roughness: 0.2 });
        const matAccent = new THREE.MeshStandardMaterial({ color: COLORS.purpleLight, roughness: 0.2 });
        const matNeonBlue = new THREE.MeshStandardMaterial({ color: COLORS.neonBlue, emissive: COLORS.neonBlue, emissiveIntensity: 2 });
        const matNeonPink = new THREE.MeshStandardMaterial({ color: COLORS.neonPink, emissive: COLORS.neonPink, emissiveIntensity: 2 });
        const matGold = new THREE.MeshStandardMaterial({ color: COLORS.gold, metalness: 0.8, roughness: 0.2, emissive: 0x553300 });
        
        // Transparent beam material
        const matBeam = new THREE.MeshBasicMaterial({ 
            color: COLORS.beam, 
            transparent: true, 
            opacity: 0.15, 
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        // --- BUILDER FUNCTIONS ---

        function createBox(w, h, d, x, y, z, material) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, material);
            mesh.position.set(x, y + h / 2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // Create a vertical light beam fading out
        function createBeam(x, z, height) {
            // Using a cylinder with no top face could simulate a beam, but a simple box works for voxel style
            const geo = new THREE.CylinderGeometry(0.8, 0.8, height, 8, 1, true);
            // Shift geometry so pivot is at bottom
            geo.translate(0, height/2, 0); 
            
            // Custom shader for fade effect (Simple vertex color gradient)
            const beamGeo = new THREE.BoxGeometry(1.5, height, 1.5);
            beamGeo.translate(0, height/2, 0);
            
            const beam = new THREE.Mesh(beamGeo, matBeam);
            beam.position.set(x, 0, z);
            scene.add(beam);
            
            // Add a bright pad at the bottom
            const pad = createBox(2, 0.2, 2, x, 0, z, matNeonPink);
            scene.add(pad);
        }

        // --- BUILDING CONSTRUCTION ---

        const cityGroup = new THREE.Group();
        scene.add(cityGroup);

        // 1. Center Building (The Bank) - Supports the Coin
        const centerGroup = new THREE.Group();
        centerGroup.position.set(0, 0, 0);
        
        // Base
        centerGroup.add(createBox(8, 2, 8, 0, 0, 0, matBase));
        // Pillars/Stripes
        for(let i=0; i<4; i++) {
            centerGroup.add(createBox(1, 12, 1, -3.5 + (i*2.3), 2, 3.5, matNeonBlue));
            centerGroup.add(createBox(1, 12, 1, -3.5 + (i*2.3), 2, -3.5, matNeonBlue));
            centerGroup.add(createBox(1, 12, 1, 3.5, 2, -3.5 + (i*2.3), matNeonBlue));
            centerGroup.add(createBox(1, 12, 1, -3.5, 2, -3.5 + (i*2.3), matNeonBlue));
        }
        // Core
        centerGroup.add(createBox(6, 12, 6, 0, 2, 0, matBase));
        // Roof Pad
        centerGroup.add(createBox(6, 1, 6, 0, 14, 0, matAccent));
        centerGroup.add(createBox(4, 0.5, 4, 0, 15, 0, matGold)); // Glowing pad for coin
        
        // Add upward beam from center
        const centerBeam = new THREE.Mesh(
            new THREE.BoxGeometry(4, 30, 4).translate(0, 15, 0),
            new THREE.MeshBasicMaterial({ color: COLORS.gold, transparent: true, opacity: 0.1, blending: THREE.AdditiveBlending })
        );
        centerBeam.position.y = 15;
        centerGroup.add(centerBeam);

        cityGroup.add(centerGroup);

        // 2. Tall Left Building (Violet)
        const leftBuild = new THREE.Group();
        leftBuild.position.set(-10, 0, 5);
        leftBuild.add(createBox(6, 25, 6, 0, 0, 0, matAccent));
        // Vertical stripes
        leftBuild.add(createBox(0.5, 25, 0.5, -3, 0, -3, matNeonBlue));
        leftBuild.add(createBox(0.5, 25, 0.5, 3, 0, 3, matNeonBlue));
        leftBuild.add(createBox(0.5, 25, 0.5, -3, 0, 3, matNeonBlue));
        leftBuild.add(createBox(0.5, 25, 0.5, 3, 0, -3, matNeonBlue));
        // Top Beam
        const lbBeam = new THREE.Mesh(new THREE.BoxGeometry(3, 10, 3).translate(0,5,0), matBeam);
        lbBeam.position.y = 25;
        leftBuild.add(lbBeam);
        cityGroup.add(leftBuild);

        // 3. Back Right Building (Dark)
        const backBuild = new THREE.Group();
        backBuild.position.set(8, 0, -8);
        backBuild.add(createBox(7, 20, 7, 0, 0, 0, matBase));
        // Grid texture effect using thin boxes
        for(let y=2; y<20; y+=3) {
            backBuild.add(createBox(7.2, 0.2, 7.2, 0, y, 0, matAccent));
        }
        const bbBeam = new THREE.Mesh(new THREE.BoxGeometry(3, 10, 3).translate(0,5,0), matBeam);
        bbBeam.position.y = 20;
        backBuild.add(bbBeam);
        cityGroup.add(backBuild);

        // 4. Far Left Short Building
        const farLeft = new THREE.Group();
        farLeft.position.set(-8, 0, 14);
        farLeft.add(createBox(6, 10, 6, 0, 0, 0, matBase));
        // Neon horizontal rings
        farLeft.add(createBox(6.2, 0.5, 6.2, 0, 3, 0, matNeonPink));
        farLeft.add(createBox(6.2, 0.5, 6.2, 0, 7, 0, matNeonPink));
        const flBeam = new THREE.Mesh(new THREE.BoxGeometry(3, 8, 3).translate(0,4,0), matBeam);
        flBeam.position.y = 10;
        farLeft.add(flBeam);
        cityGroup.add(farLeft);

        // 5. Back Middle Building
        const midBack = new THREE.Group();
        midBack.position.set(-2, 0, -12);
        midBack.add(createBox(5, 28, 5, 0, 0, 0, matAccent));
        midBack.add(createBox(3, 32, 3, 0, 0, 0, matBase)); // Inner core sticking up
        cityGroup.add(midBack);


        // --- GROUND LIGHTS ---
        // Create a grid of small glowing lights on the ground
        const groundLights = new THREE.Group();
        for (let x = -20; x <= 20; x += 8) {
            for (let z = -20; z <= 20; z += 8) {
                // Skip if too close to center (where buildings are)
                if (Math.abs(x) < 10 && Math.abs(z) < 10) continue;
                
                // Random height for beams
                const hasBeam = Math.random() > 0.5;
                if(hasBeam) {
                    createBeam(x, z, 5 + Math.random() * 5);
                } else {
                     groundLights.add(createBox(1, 0.1, 1, x, 0, z, matNeonPink));
                }
            }
        }
        scene.add(groundLights);


        // --- THE BITCOIN ---
        const coinGroup = new THREE.Group();
        coinGroup.position.set(0, 22, 0);

        // Coin Body (Cylinder rotated)
        const coinGeo = new THREE.CylinderGeometry(4, 4, 0.8, 32);
        coinGeo.rotateX(Math.PI / 2); // Make it face camera roughly
        const coinMesh = new THREE.Mesh(coinGeo, matGold);
        coinGroup.add(coinMesh);

        // The "B" Symbol (Simplified using boxes)
        const bMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5 });
        const bGroup = new THREE.Group();
        
        // Vertical line
        bGroup.add(createBox(0.6, 4, 0.2, -1, -2, 0.5, bMat));
        // Top curve blocks
        bGroup.add(createBox(2, 0.6, 0.2, 0, 1.7, 0.5, bMat));
        bGroup.add(createBox(0.6, 1.4, 0.2, 1, 1, 0.5, bMat));
        bGroup.add(createBox(2, 0.6, 0.2, 0, 0.3, 0.5, bMat));
        // Bottom curve blocks
        bGroup.add(createBox(0.6, 1.4, 0.2, 1, -1, 0.5, bMat));
        bGroup.add(createBox(2, 0.6, 0.2, 0, -1.7, 0.5, bMat));
        // Prongs
        bGroup.add(createBox(0.2, 1, 0.2, -1, 2, 0.5, bMat));
        bGroup.add(createBox(0.2, 1, 0.2, 0.5, 2, 0.5, bMat));
        
        bGroup.position.z = 0.4; // Push out slightly from coin face
        coinGroup.add(bGroup);

        // Add a glow behind the coin
        const coinGlow = new THREE.PointLight(COLORS.gold, 5, 20);
        coinGroup.add(coinGlow);

        scene.add(coinGroup);

        document.getElementById('loading').style.display = 'none';

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();

            // Rotate Coin
            coinGroup.rotation.y = time * 1.5;
            // Floating effect
            coinGroup.position.y = 22 + Math.sin(time * 2) * 1;

            // Subtle pulsing of lights
            matNeonBlue.emissiveIntensity = 1.5 + Math.sin(time * 3) * 0.5;
            matNeonPink.emissiveIntensity = 1.5 + Math.cos(time * 2) * 0.5;

            // Slowly rotate controls
            controls.update();

            // Render with Bloom
            composer.render();
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>